## 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라.

---
- 사용하는 자원에 따라 동작이 달라지는 클래스인 경우 의존 객체 주입을 사용하자.
- 사용하는 자원에 따라 동작이 달라지는 클래스는 정적 유틸리티 클래스나 싱글턴 방식은 적합하지 않다.
```java
// 정적 유틸리티 방식
public class SpellChecker {
    
    private static Dictionary dictionary = new Dictionary();

    private SpellChecker() {
    }

    public static boolean isValid(String word) {
        // ...
        return dictionary.contains(word);
    }

    public static List<String> suggestions(String typo) {
        // ...
        return dictionary.closeWordsTo(typo);
    }
}
```
```java
// 싱글턴 방식
public class SpellChecker {

    private static Dictionary dictionary = new Dictionary();

    private SpellChecker() {}
    public static final SpellChecker INSTATNCE = new SpellChecker();

    public boolean isValid(String word) {
        // ...
        return dictionary.contains(word);
    }

    public List<String> suggestions(String typo) {
        // ...
        return dictionary.closeWordsTo(typo);
    }
}
```
```java
// 의존성 주입 방식
// 코드 재사용
// dictionary를 구현받고 있는 구현체 중 사용자가 원하는 구현체로 언제든지 교체 가능 -> 유연성
public class SpellChecker {
    
    // Dictionaty가 인터페이스
    private final Dictionary dictionary;
    
    // 의존성을 주입받는 생성자
    // 자원을 어딘가에서 받을 수 있는 장치만 마련
    // 직접 자원을 명시하지 않음(new로 인스턴스를 생성x)
    private SpellChecker(Dictionary dictionary) {
        this.dictionary = dictionary;
    }

    public boolean isValid(String word) {
        // ...
        return dictionary.contains(word);
    }

    public List<String> suggestions(String typo) {
        // ...
        return dictionary.closeWordsTo(typo);
    }
}
```
```java
public class DiSpellChecker {

    private final Dictionary dictionary;

    public DiSpellChecker(Dictionary dictionary) {
        this.dictionary = dictionary;
    }

    // 자원을 만들어주는 함수형 인터페이스(Supplier)를 인자로 받음
    // Supplier<? extends Dictionary>로도 사용 가능
    public DiSpellChecker(Supplier<Dictionary> dictionarySupplier) {
        this.dictionary = dictionarySupplier.get();
    }

    public boolean isValid(String word) {
        // ...
        return dictionary.contains(word);
    }

    public List<String> suggestions(String typo) {
        // ...
        return dictionary.closeWordsTo(typo);
    }
}
// 자원을 바로 받는 것이 아닌 자원을 만들어 주는 팩토리를 통해 받음
public class DictionaryFactory {
    public static DefaultDictionary get() {
        return new DefaultDictionary();
    }
}
```