# 18. 상속보다는 컴포지션을 사용하라.

---

상속의 장단점
- 장점
  - 코드 재사용
  - 계층 구조 구축
  - 다형성
  - 확장 가능성
- 단점
  - 커플링
    - 상속을 과도하게 사용하면 클래스 간의 강력한 결합이 발생하여 유지보수와 확장이 어려움
  - 복잡성
  - 오버라이딩의 오용
  - 한정된 재사용
    - 클래스는 하나의 상위 클래스만 상속 받을 수 있기 때문에 새로운 부모 클래스를 상속 받을 수 없다.
  - `캡슐화x`
    - 상위 클래스의 내부 구현이 노출
      상위 클래스의 메서드 동작 방식을 알아야지만 하위 클래스에서 제대로 재정의할 수 있다.
      만약 상위 클래스의 구현이 바뀐다면?
      바뀐 구현에 따라서 하위 클래스 코드를 바꿔야 함.

---
  
컴포지션
- 사용하고 싶은 기능을 가진 클래스를 상속하는 것이 아닌 멤버 변수로 선언.
- 사용하고자 하는 모든 메서드들이 그 멤버 변수를 통해 사용됨.
- 이 방식을 전달(forwarding)이라 하며, 새 클래스의 메서드들을 전달 메서드(forwarding method)라 부른다.
- 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나며,
- 기존 클래스에 새로운 메서드가 추가되더라도 전혀 영향 받지 않는다.

장점
- 객체 재사용
- 객체 지향 설계
  - 작은 조각으로 객체를 조합하고 모듈화
- 캡슐화
  - 코드의 중복 제거
  - 데이터를 처리하는 방식이 외부에 드러나지 않아 정보 은닉과 보안 향상
  - 객체의 개념을 강화
- 유연성과 확장성
  - 새로운 기능을 추가한다면 클래스를 만들고 필요한 객체를 조합해서 사용.
- 낮은 결합도
  - 클래스 간의 결합도를 낮추고 독립성을 유지

상위 클래스에서 기능이 추가되었다면 문서화가 되지 않는 이상 하위 클래스에서는 알기 어려움.<br>
반대로 하위 클래스에서만 쓰는 기능이 있고 나중에 상위 클래스에서 그것과 관련된 기능이 추가되었다면 코드가 깨질 가능성 큼.

이러한 단점이 있으므로 컴포지션 사용을 권장

---

데코레이터 패턴
- 기존 코드를 변경하지 않고 부가 기능을 추가하는 패턴
  - 상속이 아닌 위임을 사용해서 보다 유연하게 부가 기능을 추가하는 것도 가능하다.
```java
// Component interface
interface Coffee {
    double getCost();
    String getDescription();
}

// Concrete Component
class SimpleCoffee implements Coffee {
    @Override
    public double getCost() {
        return 2.0;
    }

    @Override
    public String getDescription() {
        return "Simple Coffee";
    }
}

// Decorator
abstract class CoffeeDecorator implements Coffee {
    protected Coffee decoratedCoffee;

    public CoffeeDecorator(Coffee coffee) {
        this.decoratedCoffee = coffee;
    }

    public double getCost() {
        return decoratedCoffee.getCost();
    }

    public String getDescription() {
        return decoratedCoffee.getDescription();
    }
}

// Concrete Decorator
class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }

    public double getCost() {
        return super.getCost() + 0.5;
    }

    public String getDescription() {
        return super.getDescription() + ", Sugar";
    }
}

// Concrete Decorator
class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }

    public double getCost() {
        return super.getCost() + 1.0;
    }

    public String getDescription() {
        return super.getDescription() + ", Milk";
    }
}

public class DecoratorPatternExample {
    public static void main(String[] args) {
        Coffee coffee = new SimpleCoffee();
        System.out.println("Cost: " + coffee.getCost() + ", Description: " + coffee.getDescription());

        Coffee coffeeWithSugar = new SugarDecorator(coffee);
        System.out.println("Cost: " + coffeeWithSugar.getCost() + ", Description: " + coffeeWithSugar.getDescription());

        Coffee coffeeWithMilkAndSugar = new MilkDecorator(coffeeWithSugar);
        System.out.println("Cost: " + coffeeWithMilkAndSugar.getCost() + ", Description: " + coffeeWithMilkAndSugar.getDescription());
    }
}
```