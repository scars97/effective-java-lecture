## 20. 추상 클래스보다 인터페이스를 우선하라.

---

### (1) 인터페이스의 장점
- 디폴트 메서드를 제공할 수 있다.
  - 인터페이스 기능 추가 ->  구현클래스에 기능 구현 필요
  - 디폴트 메서드 사용 -> 구현클래스에 기능 구현x
```java
public interface TimeClient {
    
    // ...

    static ZoneId getZoneId (String zoneString) {
        try {
            return ZoneId.of(zoneString);
        } catch (DateTimeException e) {
            System.err.println("Invalid time zone: " + zoneString +
                    "; using default time zone instead.");
            return ZoneId.systemD1efault();
        }
    }

    // 디폴트 메서드를 직접 구현.
    default ZonedDateTime getZonedDateTime(String zoneString) {
        return ZonedDateTime.of(getLocalDateTime(), getZoneId(zoneString));
    }
}
```
- 믹스인(mixin)
  - 특정 클래스가 다른 클래스의 기능을 확장하고 추가할 수 있는 방법 중 하나.
  - 믹스인 사용 시 특정 클래스의 기능을 다른 클래스에 혼합할 수 있다.
```java
public class SimpleTimeClient implements TimeClient, Closeable {
    // ...
}
```

- 계층구조가 없는 타입 프레임워크를 만들 수 있다.
  - A, B라는 각각의 인터페이스가 있고 이 둘의 관계가 명확하지 않다면 이것을 AB인터페이스로 묶어 표현할 수 있다.
```java
public interface Singer { AudioClip strum(); }
public interface Songwriter { void actSensitive(); }
public interface SingerSongwriter extends Singer,Songwriter { 
    AudioClip strum();
    void actSensitive();
}
```
- 래퍼 클래스와 함께 사용하면 인터페이스는 기능을 향상시키는 안전하고 강력한 수단이 된다.
```java
interface Logger{
    void log(String message);
}

class LoggerImpl implements Logger {
    @Override
    public void log(String message) {
        System.out.println("Log: " + message);
    }
}

class ProductService extends LoggerImpl {
    private String name;

    public ProductService(String name) {
        this.name = name;
    }

    public void process() {
        log("Processing " + name);
    }
}

class UserService extends LoggerImpl {
    private String username;

    public UserService(String username) {
        this.username = username;
    }

    public void login() {
        log("User " + username + " logged in");
    }
}

public class Main {
    public static void main(String[] args) {
        // ProductService 사용 예제
        ProductService product = new ProductService("Product A");
        product.process();

        // UserManager 사용 예제
        UserService user = new UserService("user123");
        user.login();
    }
}
```
---

### (2) 인터페이스와 추상 골격(skeletal implementation) 클래스
- 인터페이스와 추상 클래스의 장점을 모두 취할 수 있다.
  - 인터페이스 - 디폴트 메서드 구현
    - List, Map ...
  - 추상 골격 클래스 - 나머지 메서드 구현
    - AbstractList, AbstractMap ...
  - 템플릿 메서드
- 다중 상속을 시뮬레이트할 수 있다.
- 골격 구현은 상속용 클래스이기 때문에 item19(문서화)를 따라야 한다.
```java
public class IntArrays {
    static List<Integer> intArrayAsList(int[] a) {
        Objects.requireNonNull(a);
        
        // new List<() {...} 로 리턴한다면 재정의해야할 메서드가 굉장히 많다. 
        // 추상 골격 클래스를 만들어 필요한 메서드만 추려 재정의할 수 있다.
        return new AbstractList<>() {
            @Override public Integer get(int i) {
                return a[i];  // 오토박싱(아이템 6)
            }

            @Override public Integer set(int i, Integer val) {
                int oldVal = a[i];
                a[i] = val;     // 오토언박싱
                return oldVal;  // 오토박싱
            }

            @Override public int size() {
                return a.length;
            }
        };
    }

    public static void main(String[] args) {
        int[] a = new int[10];
        for (int i = 0; i < a.length; i++)
            a[i] = i;

        List<Integer> list = intArrayAsList(a);
        Collections.shuffle(list);
        System.out.println(list);
    }
}
```

---

### (3) 템플릿 메서드 패턴
- 알고리즘 구조를 서브 클래스가 확장할 수 있도록 템플릿으로 제공하는 방법
  - 추상 클래스는 템플릿을 제공하고 하위 클래스는 구체적인 알고리즘을 제공한다.
```java
public abstract class FileProcessor {

    // ...
  
    // 템플릿 메서드
    // 알고리즘을 풀기 위한 틀 또는 방향성을 제공?
    public final int process() {
        try (BufferedReader reader = new BufferedReader(new FileReader(path))) {
            int result = 0;
            String line = null;
            while ((line = reader.readLine()) != null) {
                result = getResult(result, Integer.parseInt(line));
            }
            return result;
        } catch (IOException e) {
            throw new IllegalArgumentException(path + "에 해당하는 파일이 없습니다.", e);
        }
    }

    protected abstract int getResult(int result, int number);
}

public class Plus extends FileProcessor{
    // ...
    
    // 하위클래스는 알고리즘을 풀기 위한 구체적인 방법을 제공..
    @Override
    protected int getResult(int result, int number) {
      return result + number;
    }
}
```

---

## 핵심정리
```
일반적으로 다중 구현용 타입으로는 인터페이스가 가장 적합하다.
복잡한 인터페이스라면 구현하는 수고를 덜어주는 골격 구현을 함계 제공하는 방법을 고려하자.\

골격 구현은 가능한 한 인터페이스의 디폴트 메서드로 제공하여
그 인터페이스를 구현한 모든 곳에서 활용하도록 하는 것이 좋다.

'가능한 한'이라고 한 이유는, 인터페이스에 걸려 있는 구현상의 제약 때문에
골격 구현을 추상 클래스로 제공하는 경우가 더 흔하기 때문이다.
```