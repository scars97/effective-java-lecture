# 17. 변경 가능성을 최소화 하라.

---

## 불변 클래스
### (1) 불변 클래스를 만드는 5가지 규칙
- 객체의 상태를 변경하는 메서드를 제공하지 않는다.
  - Setter를 사용하지 않는다.
- 클래스를 확장할 수 없도록 한다.
  - 상속할 수 없게 클래스에 final 선언
- 모든 필드를 final로 선언한다.
- 모든 필드를 private을 선언한다.
- 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 수정하는 일을 막아준다.
- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다. 또는 방어적 복사를 사용한다.
  - 가변 객체를 참조하는 필드가 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야한다.

---

### (2) 장점, 단점 
※ [함수형 프로그래밍](https://mangkyu.tistory.com/111)에 적합하다
- 부수효과(Side Effect)가 없는 순수 함수를 1급 객체로 간주하여 파라미터난 반환값으로 사용가능하며, 참조 투명성을 지킬 수 있다.  
- 피연산자에 함수를 적용해 그 결과를 반환하지만, 피연산자 자체는 그대로인 프로그래밍 패턴
```java
public final class Complex {
    private final double re;
    private final double im;

    public Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public double realPart() {
        return re;
    }

    public double imaginaryPart() {
        return im;
    }

    // 사칙연산 메서드들이 자신(Complex)은 수정하지 않고
    // 새로운 인스턴스를 만들어 반환.
    public Complex plus(Complex c) {
        return new Complex(re + c.re, im + c.im);
    }

    public static Complex valueOf(double re, double im) {
        return new Complex(re, im);
    }

    public Complex minus(Complex c) {
        return new Complex(re - c.re, im - c.im);
    }

    public Complex times(Complex c) {
        return new Complex(re * c.re - im * c.im,
                re * c.im + im * c.re);
    }

    public Complex dividedBy(Complex c) {
        double tmp = c.re * c.re + c.im * c.im;
        return new Complex((re * c.re + im * c.im) / tmp,
                (im * c.re - re * c.im) / tmp);
    }
}
```

---
