# 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라

---

## 가변인수
- 인수의 개수와 타입이 미리 정해져 있지 않음.
- 가변인수는 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해줌.
- 가변인수 메서드를 호출하면 가변인수를 담기 위한 배열이 자동으로 만들어짐.
- 내부로 감춰야 했을 이 배열을 클라이언트에게 노출하는 문제
- 가변인수 매개변수에 제네릭이나 매개변수화 타입이 포함되면 알기 어려운 컴파일 경고가 발생

## 제네릭 가변인수(varags) 배열에 값을 저장하는 것은 안전하지 않다.
- 매개변수화 타입의 변수가 타입이 다른 객체를 참조하면 힙 오염이 발생
- 다른 타입 객체를 참조하는 상황에서 컴파일러가 자동 생성한 형변환이 실패할 수 있으니,
- 제네릭 타입 시스템이 약속한 타입 안정성이 깨진다.
```java
// 제네릭과 varags를 혼용하면 타입 안정성이 깨진다.
static void dangerous(List<String>... stringLists) {
    List<Integer> intList = List.of(42);
    Object[] objects = stringLists;
    object[0] = intList;                // 힙 오염 발생
    String s = stringLists[0].get(0);   // ClassCastException
}
```
<blockquote>
제네릭 varags 매개변수를 받는 메서드를 선언할 수 있게 한 이유? <br>
- 제네릭이나 매개변수화 타입의 varags 매개변수를 받는 메서드가 실무에서 매우 유용
</blockquote>

## @SafeVarags 애너테이션은 메서드 작성자가 그 메서드가 타입 안전함을 보장하는 장치
- 자바 7전에는 가변인수 메서드를 호출하는 곳마다 @SuppressWarnings("unchecked") 을/를 달아 경고를 숨겨야 했다.
- 이휴, @SafeVarags가 추가되어 제네릭 가변인수 메서드 작성자가 클라이언트 측에서 발생하는 경고를 숨길 수 있게 되었다.
- 메서드가 안전한 게 확실하지 않다면 절대 @SageVarags를 달아서는 안 된다.

### 메서드가 안전한지 어떻게 확신할 수 있을까?
- 가변인수 메서드를 호출할 때 varags 매개변수를 담는 제네릭 배열이 만들어진다.
- 메서드가 이 배열에 아무것도 저장하지 않고, 그 배열의 참조가 밖으로 노출되지 않는다면 타입 안전.
- varags 매개변수 배열이 호출자로부터 순수하게 인수들을 전달하는 일만 한다면 타입 안전한 것. 
