# 26. 로 타입은 사용하지 말라.

---

## (1) 제네릭?
- 클래스와 인터페이스 선언에 타입 매개변수가 쓰이면, 이를 제네릭 클래스, 제네릭 인터페이스라 한다. -> 제네릭 타입
- 제네릭 타입은 일련의 매개변수화 타입을 정의한다.
- 먼저 클래스 이름이 나오고, <> 안에 실제 타입 매변수들을 나열한다.
  - `List<String>`은 원소의 타입이 `String인 리스트`를 뜻하는 매개변수들을 나열한다.
```java
List<String> listOfString = new ArrayList<>();
Map<String, ClassName> mapOfStringClassName = new HashMap<>();
```

**장점**
- 제네릭을 사용하면 잘못된 타입이 들어올 수 있는 것을 `컴파일 단계에서 방지`할 수 있다.
- 클래스 외부에서 타입을 지정해주기 때문에 따로 타입을 체크하고 변환해줄 필요가 없다.
- 비슷한 기능을 지원하는 경우 코드의 재사용성이 높아진다.

### 로 타입 (raw type)
- 로 타입은 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말함.
- 로타입을 쓰면 <u>제네릭이 안겨주는 안선성과 표현력을 모두 잃게 된다.</u>

```java
// 로 타입 예제
// 런타임 실패
public class Raw {
    public static void main(String[] args) {
        List<String> strings = new ArrayList<>();
        unsafeAdd(strings, Integer.valueOf(42));
        String s = strings.get(0); // 형변환하려 할 때 ClassCastException을 던진다.
    }

    // 로 타입 사용
    // List<Object>로 바꾼다 해도 여전히 컴파일 오류
    private static void unsafeAdd(List list, Object o) {
        list.add(o);
    }
}
```
```
※ 로타입을 왜 만들었을까?
- 제네릭이 등장하기 전, 코드와 호환되도록 하기 위한 지책.
- 제네릭이 사용되면서 기존 코드와 새로운 코드가 맞물려 돌아가게 해야만 했음.
- 마이그레이션 호환성을 위해 로 타입을 지원하고 제네릭 구현에는 소거 방식을 사용.
```
```
※ 공변과 불공변
일반적으로 String은 Object의 하위타입이므로 형변환이 가능하다. 이것을 공변이라 말한다.
하지만 위 코드의 List<String>은 List<Object>의 하위 타입이 아니다.
그 이유는 제네릭이 불공변이기 때문인데 제네릭은 타입 안정성과 일관성을 유지하기 위해
타입 간의 할당 및 형 변환을 허용하지 않는다.
그렇기 때문에 와일드 카드가 등장한 것.
```

### 와일드 카드
- 제네릭 코드에서 물음표로 표기되어 있는 것, 아직 알려지지 않은 타입을 말함.

**한정적 와일드카드(Bounded Wildcards)**
- 특정 타입을 기준으로 상한 범위와 하한 범위를 지정

```java
// 상한 경계 와일드카드 : extends를 사용해서 와일드카드 타입의 최상위 타입을 정의
void boundedExample(Collection<? extends Parent> b) {
     // ...
}
```
```java
//하한 결계 와일드카드 : super를 사용해 와일드카드의 최하위 타입을 정의
void boundedExample(Collection<? super Parent> b) {
      // ...
}
```

**비한정적 와일드카드(Unbounded Wildcards)**
- 특정한 타입 매개변수를 지정하지 않고 ?로 표기
- 읽기 작업(요소를 가져오는 것)에 대해서는 안전하게 사용가능하지만, <br> 쓰기 작업(요소를 추가하거나 변경하는 것)은 허용되지 않는다.
- 그 이유는 타입 안정성을 보장하기 위해서인데 타입 안정성이 유지됐을 때 <br> 컴파일러는 컴파일 시에 타입 검사를 수행하며, 런타임 오류를 방지할 수 있다.
```java
public void printList(List<?> list) {
    for (Object item : list) {
        System.out.println(item);
    }
}
```
