# 28. 배열보다는 리스트를 사용하라.

---

## 배열과 제네릭의 차이

### (1) 공변과 불공변
- 배열은 공변.
  - Sub가 Super의 하위 타입이라면 Sub[]는 Super[]의 하위 타입
- 제네릭은 불공변.
  - List<Type1>은 List<Type2>의 하위 타입도, 상위 타입도 아니다.
- 배열에서는 실수를 런타임에야 알게 되지만, 리스트를 사용하면 컴파일할 때 바로 알 수 있다.
```java
// 런타임 실패
Object[] objectArray = new Long[1];
objectArray[0] = "타입이 달라 넣을 수 없다." // ArrayStoreException

// 컴파일 되지 않음
List<Object> ol = new ArrayList<Long>(); // 호환되지 않는 타입이다.
ol.add("타입이 달라 넣을 수 없다.");
```

### (2) 실체화(reify)와 소거(erasure)
- 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다.(실체화)
  - 위 코드의 Long배열에 String을 넣으려 하면 ArrayStoreException이 발생하는 이유임.
- 제네릭은 타입 정보가 런타임에 소거된다.
  - 원소 타입을 컴파일 타임에만 검사하며 런타임에는 알 수 없다.

<blockquote>
※ 소거 <br>
제네릭이 지원되기 전의 레거시 코드와 제네릭 타입을 함께 사용할 수 있게 해주는 메커니즘
</blockquote>

---

## 제네릭 배열 생성을 허용하지 않는 이유
- 타입 안전하지 않기 때문.
- 허용한다면 컴파일러가 자동 생성한 형변환 코드에서 런타임에 ClassCastException이 발생할 수 있다.
