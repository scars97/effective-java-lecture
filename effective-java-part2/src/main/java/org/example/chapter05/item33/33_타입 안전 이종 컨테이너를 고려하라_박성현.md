# 33. 타입 안전 이종 컨테이너를 고려하라.

---

## 타입 안전 이종(다른) 컨테이너
한 타입의 객체만 담을 수 있는 컨테이너(Map, Set, Optional 등)가 아니라 <br>
여러 다른 타입을 담을 수 있는 타입 안전한 컨테이너

- 타입 토큰
  - 컴파일타임 타입 정보와 런타임 타입 정보를 알아내기 위해 메서드들이 주고받는 class 리터럴 
  - String.class 또는 Class<String>
- 컨테이너가 아니라 "키"를 매개변수화 하라
```java
public class Favorites {

    private Map<Class<?>, Object> map = new HashMap<>();

    public <T> void put(Class<T> type, T instance) {
        this.map.put(Objects.requireNonNull(type), instance);
    }

    public <T> T get(Class<T> type) {
        // cast()는 형변환 연산자의 동적 버전
        // 주어진 인수가 Class 객체가 알려주는 타입의 인스턴스인지 검사
        // true일 시 인수를 그대로 반환
        // false일 시 ClassCastException
        return type.cast(this.map.get(type));
    }

    public static void main(String[] args) {
        Favorites favorites = new Favorites();
        favorites.put(String.class, "seong");
        favorites.put(Integer.class, 2);
        String s = favorites.get(String.class);
        Integer integer = favorites.get(Integer.class);
    }
}
```
- 위의 코드는 타입 안전하지만 put()을 사용할 때 로타입을 사용하여 우회하는 방법이 존재
- instance에도 cast()를 사용하면, 컴파일 에러는 잡을 순 없지만 조기에 에러를 발견할 수 있다.
```java
public class Favorites {
    // ...

    // Class로 형변환시 T에 타입이 매핑되지 않아 컴파일시 T는 Object로 변경
    // 기존 String이 아닌 데이터도 입력되는 오류 발생
    public <T> void put(Class<T> type, T instance) {
        // 동적 형변환(cast())으로 런타임 타입 안전성 확보
        this.map.put(Objects.requireNonNull(type), type.cast(instance));
    }

    // ClassCastException 발생
    public <T> T get(Class<T> type) {
      return type.cast(this.map.get(type));
    }

    public static void main(String[] args) {
        Favorites favorites = new Favorites();
        
        favorites.put((Class)String.class, 1);
    }
}
```